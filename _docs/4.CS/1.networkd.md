---
title: Network
category: Computer Science
order: 1
---

<details markdown = "1">
<summary>네트워크 간단 지식 정리</summary>

- `네트워크` : 노드와 링크가 서로 연결되어 있으며 리소스를 공유하는 집합을 의미합니다.
- `노드` : 서버, 라우터, 스위치등 네트워크 장치
- `링크(엣지)` : 노드와 노드를 연결하는 매체, 유선 또는 무선과 같은 연결매체(와이파이나 LAN)
- `트래픽` : 특정 시점에 링크 내의 흐르는 데이터의 양 (트래픽 이많다 == 흐르는 데이터가 많아졌다, 처리량이 많다 == 처리되는 트래픽이 많다)
- `대역폭` : 주어진 시간 동안 네트워크 연결을 통해 흐를 수 있는 최대 비트 수 or 최대로 처리할 수 있는 트래픽
- `RTT(Round Trip Time)` : 데이터 패킷이 송신자로부터 수신자까지 가는 시간과 그 반대 방향으로 돌아오는 전체 시간을 의미
- `네트워크 토폴로지` : 네트워크에 참여하는 링크 및 노드들의 배치 형태 및 망구성방식을 의미(버스,스타,트리 형 존재), 병목현상을 해결하는 척도
- `버스 토폴로지` : (하나의 링크에 여러 노드 있는 형태) 소규모 네트워크 구축하기 쉽고, 한 노드 장애나도 따른데 영향 X, 메인 링크에 많은 트래픽 생기면 정체 현상 발생, 메인 링크 망가지면 문제
- `스타 토폴로지` : (중앙에 노드를 기반으로 연결된 형태) 중앙 노드 아닌 한 노드에 장애 발생 시 따른 영향 X, 다른 노드 가려면 중앙 노드 거쳐야함(중앙에 방화벽), 안정적, 중앙 노드 에러 시 큰 문제
- `트리 토폴로지(계층적)` : 노드 추가 삭제는 보통, 리프 노드 에러는 나머지 영향 X, 특정 노드 트래픽 집중시 하위 노드에 영향, 루트 노드 문제 시 다 문제(백본 케이블 기반으로 연결)
- `백본 케이블` : 여러 소형 네트워크를 묶어 대규모 파이프 라인을 통해, 높은 대역폭으로 다른 네트워크 집합과 연결되는 네트워크
- `링형 토폴로지` : (고리 형태), 연결리스트 처럼 노드 추가 삭제 쉬움, 토큰을 기반으로 연속적으로 노드 거치며, 권한이 없는 노드는 데이터 안받음, 토큰이 없는 노드는 통신 참여 불가
- `메시 토폴로지` : (그물망으로 다 연결된 상태) 노드 추가 및 삭제 어려움(많이 연결되어있어서), 안정성은 높음(한 노드 장애 나도 다른 노드 영향 X), 트래픽 분산, 구축 비용이 고가라는 단점
- `병목현상(bottleNek)` : 트래픽에 의해 데이터의 흐름이 제한된 상황(토폴로지를 안다면 어떤 회선 또는 서버의 용량을 증가시켜야 하는지 파악 가능)
- `유니캐스트` : 1대1 통신으로 대표적으로 HTTP 통신
- `멀티캐스트` : 1대N 통신으로 연결된 모든 노드들에게 데이터를 전달하지는 않고, 특정 그룹에게만 데이터를 전달
- `애니캐스트` : 연결된 모든 노드에게 데이터를 전달(대표적으로 ARP)
- `근거리 통신망(LAN)` : 근거리 통신망으로, 높은 안정성과 속도를 가집니다. 하나의 논리적 주소인 IP를 기반으로 여러개의 물리적 주소인 MAC 주소로 구별하는 네트워크(허브나 스위치로 연결됨)<br>
- `대도시 통신망(MAN)` : 도시와 도시의 통신망을 뜻하며 2개 이상의 LAN이 연결되어 구성됩니다.(라우터 브리지 등으로 연결되어 있음)
- `광역 통신망(WAN)` : 국가와 국가와의 통신, 제일 혼잡
- `TCP/IP 4계층` : 장치들이 인터넷 상에서 데이터를 주고받을 때 쓰는 독립적인 프로토콜 집합
- `애플리케이션 계층` : HTTP, SMTP, SSH, FTP 등이 있다. 웹 서비스, 이메일 등 서비스를 실질적으로 사람들에게 제공하는 층
- `전송 계층` : TCP, UDP등이 있다. 애플리케이션 계층에서 받은 메세지를 기반으로 세그먼트 또는 데이터그램으로 쪼개고, 데이터가 오류없이 순서대로 전달되도록 하는 층
- `인터넷 계층(network 계층)` : IP, ICMP, ARP 등이 있음. 세그먼트 또는 데이터그램을 패킷화하여 목적지로 전송하는 역할
- `링크 계층` : 물리 계층 + 데이터 링크 계층, 전선 광섬유 등이 있다. 데이터가 네트워크를 통해 물리적으로 전송되는 방식 정의
- `캡슐화` : 캡슐화는 데이터를 보낼때(송신자 -> 수신자), 데이터가 각 계층을 지나며 각 계층의 특징들이 담긴 헤더들이 붙여지는 과정 의미
- `비캡슐화` : 캡슐화 역과정, 캡슐화된 데이터를 역순으로 제거하면서 응용계층까지 도달하는 과정
- `PDU(Protocol Data Unit)`: 각 계층의 데이터 단위
    - 애플리케이션(메세지), TCP(세그먼트), UDP(데이터그램), 인터넷(패킷), 데이터 링크(프레임), 물리계층(비트)
- `세그먼트 or 데이터 그램` : 적절한 크기로 쪼갠 조각
- `패킷` : 세그먼트에 SP(송신자 IP)와 DP(수신자 IP)가 포함된 IP헤더가 붙은 형태의 조각
- `프레임` : MAC 주소 헤더와 CRC/체크섬 트레일러가 붙은 조각
- `MTU(Maximum Transmission Unit)` : 네트워크에서 전송될 수 있는 최대 데이터 패킷의 크기를 의미하며, 이 크기를 초과하는 데이터는 패킷으로 분할되어 전송됩니다
- `SSH(Secure Shell Protocol)` : 보안되지 않은 네트워크에서 네트워크 서비스를 안전하게 운영하기 위한 암호화 네트워크 프로토콜
- `FTP(File Transfer Protocol)` : 노드와 노드간 파일을 전송하는데 사용되는 프로토콜
- `SMTP` : 인터넷을 통해 메일을 보낼때 사용되는 프로토콜
- `TCP` : 가상 회선 패킷 교환 방식 사용, 오류 검사 메커니즘으로 재전송이나 체크섬 사용, 헤더 크기가 가변적
- `UDP` : 데이터 그램 패킷 교환 방식(순서 보장 X), 오류검사는 단순한 체크섬만 제공, 헤더가 8바이트로 고정, 쓰리웨이 포웨이 핸드쉐잌도 안함
- `ICMP(Internet Control Message Protocol)` : 노드와 노드사이에서 통신이 잘되나 확인하는 프로토콜
- `3-웨이 핸드쉐이크` : TCP의 연결 성립 과정. 
    - 클라이언트는 서버에 클라이언트의 ISN(고유번호)을 담아 SYN을 보냄(SYN 단계)
    - 서버는 클라이언트의 SYN을 수신하고, 서버의 ISN을 보내며, 승인번호로 클라이언트의 ISN + 1을 보냄(SYN/ACK)
    - 클라이언트는 서버의 ISN+1한 값인 승인번호를 담아 ACK를 서버에 보냄(ACK)
- `ISN` : TCP 기반 통신에서, 각각의 새연결에 할당된 고유한 시퀀스 번호
- `라우팅` : 네트워크에서 패킷(데이터)를 보낼때 최적의 경로를 선택하는 과정이며 라우터가 이를 수행. 데이터는 목적지로 가능동안 여러 라우터를 거치며 여러 번 라우팅 수행
- `라우터` : 네트워크 사이에서 데이터를 전달하는 장치로, 둘 이상의 서로 다른 네트워크에 연결. 데이터를 목적지로 보낼 때 최적의 경로를 결정하고, 경로가 결정되면 해당 경로로 데이터를 넘겨주는 일을 수행(라우팅 테이블 기반)<br>
- `게이트 웨이` : 서로 다른 네트워크나 프로토콜 간의 통신을 가능하게 하는 장치(라우터랑 비슷)
- `홉` : 데이터 패킷이 소스에서 목적지로 전송되는 동안 거치는 네트워크 장치(예 : 라우터) 숫자
- `IP주소` : 인터넷 프로토콜에 할당된 장치의 고유한 숫자 주소로, 네트워크 상에서 특정 장치를 식별하기 위해 사용
- `MAC주소` : NIC(네트워크 인터페이스 카드)에 할당된 고유한 하드웨어 주소로, 물리적 네트워크 상에서 장치를 식별하기 위해 사용
- `ARP(Address Resolution Protocol)` : IP 주소를 기반으로 해당 장치의 MAC 주소를 알아내기 위한 프로토콜 (반대로 하면 RARP)
    - MAC 주소 찾기 위해 브로드 캐스팅을 통해 데이터를 연결된 네트워크 장치에 모두 보냄
    - 맞는 장치가 있다며해당 장치는 유니캐스트로 데이터를 전달해 주소를 찾음
- `IPV4` : 32비트로 표현되는 주소체계로 8비트씩 4개로 구분(10진수로 표현)
- `IPV6` : 128비트로 표현되는 주소체계로 16비트씩 8개로 구분(16진수로 표현)
    - IPV6에는 데이터 패킷을 암호화하는 IPSec이 내장되어있고, 불필요한 필드를 제거하여 빠른 처리가 가능(보안도 좋고)
- `서브넷 마스크` : IP주소의 네트워크 부분과 호스트 부분을 구분하는데 사용. 4개의 8비트 옥텟으로 구성되어있음.(네트워크 주소 부분은 모두 1, 호스트 주소는 0)
- `IP 주소 클래스` : 주소 공간 효율적으로 관리하기 위해 클래스로 나누어짐.클래스 A에서 네트워크 주소는 첫 옥텟, 나머지는 호스트 주소. B는 1,2옥텟이 네트워크 나머지 호스트, C는 1,2,3 옥텟이 네트워크 나머지 호스트
- `프라이빗 IP` : 네트워크 내부(ex: 가정 회사)에서만 사용되는 주소로, 전세계적으로 유일하진 않지만 하나의 네트워크 내에서 유일함, 외부에서 직접 접근은 불가
- `공용 IP` : 인터넷 서비스 공급자에 의해 할당되는, 전세계 유일한 IP주소, 외부에서 접근 가능
- `NAT(Network Address Translation)` : 사설 IP를 공인 IP로 변환하거나, 반대로 변환하는 기술. 라우터나 방화벽에서(공유기도) 주로 사용되며, 내부 네트워크의 기기가 외부와 통신할때 IP 주소변환 담당
- `대칭 암호화` : 암호화와 복호화에 같은 키를 사용하는 방식(AES, DES)
- `비대칭 암호화` : 암호화와 복호화에 사용하는 키가 다른 방식. 공개키로 암호화하면 비밀키로만 복호화 가능(RSA, ECC, DSA)
- `TLS` : 웹 브라우저와 서버간의 통신을 암호화하여 다양한 공격으로부터 보호하는 프로토콜, SSL 후속 버전. HTTPS를 가능하게 하는 프로토콜.
- `로컬 스토리지` : 웹 스토리지 객체로 브라우저 내에 key:value 형태로 오리진에 종속되어 저장되는 데이터
    - 로컬 스토리지의 경우엔 탭이나 창을 닫어도, 만료 안됨. 캐시를 위해 주로 사용. 사용자 행위나 로그인을 유지하기 위한 값등으로 사용되며, 여기 있는건 자동으로 서버 전송X(쿠키는 전송됨)
- `오리진` : 프로토콜 + 호스트 네임 + port 형식 -> ex)search.shopping.naver.com
- `웹 캐싱 사용 이유` : 로그인 유지, 캐싱, 자동완성 등
- `세션 스토리지` : 로컬 스토리지와 개념 같게 말해도됨, 근데 사용자가 탭을 닫으면 데이터가 만료된다는 특징
- `쿠키` : 웹 캐시와 관련있음, 브라우저에 저장된 데이터 조각. 보통 서버에서 먼저 쿠키를 만들어 Set-Cookie 헤더에 추가해서 보내면, 클라이언트에서 요청헤더 Cookie에 설정되어 자동으로 서버에 전달되고 브라우저에도 저장됨
    - 세션 쿠키 : Expires 또는 Max-Age 적용 안한거. 브라우저 종료되면 쿠키도 사라짐
    - 영구 쿠키 : Expires, Max-Age 적용해서. 특정 날짜 또는 기간 지나며 삭제되는 쿠키. 브라우저 닫을때 만료 X
    - Secure : https로만 쿠키를 주고받을 수 있게 하는 옵션
    - httpOnly : 공격자가 자바스크립트로 뺴낼수 없게함
- `로컬, 세션 스토리지, 쿠키의 공통점과 차이점` : 브라우저에 캐싱을 함으로서 서버로의 요청을 줄여 부하 방지함
- `세션, 세션 ID` : 세션이란 서버와 클라이언트의 연결이 활성화된 상태 의미, ID는 웹 서버 또는 DB에 저장되는 클라이언트에 대한 유니크 ID
- `세션 기반 로그인 프로세스` : 처음 로그인 -> 세션 ID 생성 -> 서버에서 세션 ID를 쿠키로 설정해서 클라이언트에 전달 -> 클라이언트가 서버에 요청 보낼때 세션 ID를 추가해서 보냄 -> 이를 통해 전에 로그인한 아이디인지 확인 가능
- `토큰 기반 인증` : refresh토큰과 access 토큰 두개를 기반으로 구현. 보통 액세스(인증위한)는 짧게, 리프레시 길게
- `HTTP 상태 코드` : 1xx는 요청 잘 받았고 처리하는 중, 2xx 요청 잘 처리 후 데이터 보냄, 3xx : 클라이언트 요청에 대한 완료 위해 추가 작업 필요, 4xx : 요청한 페이지 제공할 수 없거나 요청이 잘못됨, 5xx : 서버가 요청을 처리하지 못하는 상태
- `레이어별 네트워크 장치` : `애플리케이션 계층` -> L7 `전송 계층` -> L4 `네트워크 계층` -> 라우터, L3 `데이터 링크 계층` -> L2 스위치, 브리지  `물리 계층` -> NIC, 리피터, ARP
- `L7 스위치` : 로드밸런서라고도 하며, 서버의 부하를 분산함.(서버 이중화 및 보안에 강점) IP, PORT뿐 아니라 url,헤더,쿠키 등을 기반으로 트래픽 분산, 헬스 체크를 통해 장애 발생 서버 확인 후 거기에 트래픽 안보냄
- `헬스 체크` : 정상적인 서버 또는 비 정상적 서버 판별함, 반복적으로 서버에 요청을 보내면서 확인(ex: 3웨이 핸드쉨)
- `L4 스위치` : 패킷의 IP주소와 포트 번호를 통해 트래픽 분산
- `L3 스위치` : L2스위치 기능 + 라우팅을 하는 장비
- `L2 스위치` : 장치들의 MAC 주소를 관리하고, 네트워크 계층에서 받은 패킷을 기반으로 이더넷 프레임을 만들어 목적지 MAC주소에 패킷을 보내주는 역할
- `브리지` : 두개의 LAN을 상호 접속할 수 있도록 하는 통신망 연결 장치
- `리피터` : 신호를 증폭하여 전달하는 장치
- `전 이중화 통신` : 두 장치가 동시에 서로에게 데이터를 송수신 할 수 있는 방식
- `반이중화 통신` : 두 장치 간에 한번에 한방향으로만 데이터를 송수신 할 수 있는 방식(워키토키 같음)
- `서버 과부하` : 서버가 리소스를 소진하여 들어오는 요청을 처리하지 못할때 발생(ex: 503), 이유는 보통 자원의 한계점 도달임. 서버의 CPU 사용량이 80~90프로에 도달하거나, 메모리가 부족해서 계속해서 스와핑이 발생하면 과부하 -> 모니터링을 통한 자원의 적절한 할당 필요
- `AWS 오토 스케일링` : 서비스 이용 불가능 상태 이전 cloud watch가 계속해서 모니터링하고, 자원의 용량을 자동으로 조정하는 방법(용량 조정시 시간 오래걸려 로드 밸런서도 둠)
- `서킷 브레이커` : 서비스 장애를 감지하고 연쇄적으로 생기는 에러를 방지하는 기법. 서비스와 서비스사이에 서킷브레이커 계층두고, 미리 설정해둔 timeout 임계값에 도달하면 서킷 브레이커가 그 이후의 추가호출에 무조건 에러를 반환함 -> 연쇄 오류전파를 끝내는 방법
- `대규모 트래픽 서버 부하 해결` : 오토 스케일링이나, 서킷 브레이커 외에 우선 불필요한 컨텐츠 제거하기. 분산된 서버 네트워크(CDN)를 기반으로 컨텐츠를 제공해서 메인 서버 부하를 줄임. 해당 트래픽 자체가 발생안하도록 캐싱을 사용
</details>

## 물어볼것 같은 질문들

<details markdown = "1">
<summary>OSI 7계층</summary>
<img src = "https://github.com/wookjongkim/cs-study/assets/121083077/d18d26a6-8a28-482e-b37e-5b758251759f">
<br>
OSI 7계층은 네트워킹에서의 통신 프로세스를 이해하기 위한 표준 모델입니다.<br>

- `7계층(application layer, 응용계층)` : 최종 목적지로 응용프로그램과 연관해 서비스를 수행하는 계층입니다. 이메일 , 웹사이트 조회 등 어플리케이션 서비스 제공(HTTP,FTP,DNS 등이 있다)
- `6계층(Presentation layer, 표현 계층)` : 데이터의 암호화, 압축,변환등을 담당하는 계층입니다.(JPEG, MPEG 등)
- `5계층(Session layer, 세션 계층)` : 통신 세션을 구성하고 유지하기 위한 기능을 담당하는 계층입니다.(API, SOCKET)
- `4계층(Transport layer, 전송 계층)` : 종단 간의 사용자들에게 신뢰성 있는 데이터를 전달하기 위한 계층입니다.단위 세그먼트 or 데이터 그램(TCP,UDP)
  - 흐름제어 : 송신측, 수신측 사이의 데이터 처리 속도 차이 제어
  - 혼잡제어 : 네트워크 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도 제어
  - 오류제어 : 오류 검출 및 잘못된 패킷 재전송 등 관리
- `3계층(Network layer, 네트워크 계층)` : IP를 지정하고 라우터로 경로를 선택해 (네트워크를 통해) 패킷을 전송하는 계층(Router), 단위 패킷
- `2계층(Data Link Layer, 데이터 링크 계층)` : 프레임 단위의 데이터 전송과 MAC 주소를 이용한 통신을 처리하는 계층.단위 프레임. 신뢰성 있는 전송 위해 에러 검출 및 흐름제어 담당(이더넷 프로토콜, 스위치)
- `1계층(Physical Layer, 물리 계층)` : 데이터를 전기 신호로 변환 및 제어하는 계층, 단위 비트(리피터 ,허브)

<br>
전송 계층은 전체 통신 경로(최초 송신자와 최종 수신자 간)를 걸쳐 데이터의 안정성 보장, 데이터 링크 계층은 직접 연결된 두 장치간의 데이터 전송 관리<br>
<br>
꼬리질문 1 - 왜 각 계층은 나누어져 있을까요??<br>
통신이 일어나는 과정을 단계별로 잘 확인할 수 있고, 특정 계층에 문제가 말생하면 해당 계층만을 수정하거나 조정함으로서 다른 계층의 장비나 소프트웨어에 영향을 미치지 않고 효율적으로 문제 해결 가능<br>
</details>

<details markdown = "1">
<summary>인캡슐레이션과 디캡슐레이션에 대해 설명해주세요.</summary>
인캡슐레이션은 데이터를 보낼때, 데이터가 각 계층을 지나며 각 계층의 특징이 담긴 헤더들이 붙여지는 과정이고, 디캡슐레이션은 캡슐화된 데이터를 역순으로 제거하면서 응용계층까지 도달하는 과정입니다.
</details>

<details markdown = "1">
<summary>전송계층과 데이터 링크 계층 모두 신뢰성과 관련된 기능을 제공하는데, 어떤 차이가 있는지</summary>
전송계층은 논리적으로 연결된, 종단간의 호스트에 신뢰성 관련 기능(흐름 제어, 혼잡제어, 오류제어)를 제공합니다.<br>
데이터 링크 계층은 물리적으로 연결된 호스트 사이의 전송으로 직접 묶여있는 호스트-노드 혹은 노드-노드 간의 신뢰성 관련 기능(오류제어, 흐름제어, 회선 제어)를 제공합니다.<br>
<br>
한줄 요약 : 전송 계층은 논리적 연결(종단간 호스트) / 데이터링크 계층은 물리적 연결(인접한 노드 or 호스트)
</details>

<details markdown = "1">
<summary>전송 계층이 데이터 분실(패킷 추적)을 확인하는 방법에 대해 설명해주세요.(TCP 에서)</summary>
전송 계층은 세그먼트 마다 고유한 시퀀스 번호를 부여하여 전송합니다.(이후 수신자 측에서 재조립 -> 이를 통해 패킷 분실 여부 확인)<br>
수신측은 정상적으로 데이터를 받으면 해당 패킷의 시퀀스 번호와 함께 확인 응답(ACK)을 송신측에 보냅니다.<br>
송신측은 데이터를 보낸 후 일정 시간 동안(타임 아웃) 확인 응답을 기다리는데, 송신 측이 타임아웃 내에 확인 응답을 받지 못하면 해당 패킷을 분실로 간주하고 다시 전송합니다.<br>
</details>

<details markdown = "1">
<summary>전송계층이 제공하는 신뢰성 관련 기능 중, 흐름제어에 대해 설명해주세요.</summary>
흐름제어는 송신자와 수신자 간의 데이터 처리 속도 차이를 조절하여 통신의 효율성과 안정성을 보장하는 기능입니다.<br>
특히, 수신자의 버퍼가 넘치지 않도록 데이터 전송 속도를 조절하는데 중점을 둡니다.(송신측의 속도가 빠르면 문제가 된다는 것)<br>
이러한 흐름 제어 기법엔 대표적으로 슬라이딩 윈도우가 있습니다.(Stop and Wait도 있음)<br>
<img src = "https://github.com/wookjongkim/cs-study/assets/121083077/adeae7bf-09df-4e93-b9f9-5be754c8316e">
<br>
슬라이딩 윈도우(Go Back N ARQ)는 특정 크기의 윈도우를 사용해 일정량의 패킷(세그먼트)들을 송신자로부터 수신자에게 보내는 기법입니다.<br>
슬라이딩 윈도우 내의 패킷들 중 ACK를 받지 못한 패킷들이 윈도우에 남게됩니다.<br>
전송된 패킷을 잘 받았다는 ACK 신호가 수신자로부터 송신자로 돌아오면, 해당 패킷의 수만큼 슬라이딩 윈도우는 앞으로 이동합니다.<br>
이러한 로직을 통해 한번에 다량의 패킷을 전송하면서 수신자의 버퍼가 오버플로우 되는 현상을 막을 수 있습니다.<br>
</details>

<details markdown = "1">
<summary>전송계층이 제공하는 신뢰성 관련 기능 중, 오류제어(재전송 프로토콜)에 대해 설명해주세요.</summary>
오류제어는 데이터 통신 과정에서 발생할 수 있는 패킷의 손상이나 손실을 대처하는 방법입니다.<br>
이를 위해 재전송 프로토콜이라는 기법을 사용합니다.<br>
<br>

`Stop and Wait` 방식은 송신자가 데이터를 보내고, 해당 데이터에 대한 응답 (ACK)을 수신자로부터 받기 전까지 다음 데이터를 보내지 않습니다.<br>
이 방식은 간단하지만 네트워크의 전체 사용률을 높이기 어렵습니다.<br>
`Go-Back-N` 방식은 송신자가 여러 데이터를 연속으로 보내지만, 수신자가 오류를 감지하면 해당 오류가 발생한 지점부터 모든 데이터를 재전송합니다.<br>
성공한 데이터를 다시 보낼수도 있기에 약간의 비효율성이 발생할 수 있습니다.<br>
`Selective Repeat (SR)` 오류가 발생한 특정 데이터만 재전송하는 방식입니다.<br>
수신자가 데이터를 순차적으로 수신하지 않기 때문에, 데이터의 재정렬 과정이 필요합니다. 또한, 별도의 버퍼 공간이 요구됩니다<br>
<br>
순차적 수신 예시<br>
예를들어 패킷 1,2,3,4,5 순서대로 송신되었는데 3에서 오류 발생하면 3만 재전송을 요청<br>
이때 수신자 버퍼엔 이미 4,5가 도착했을수 있기에, 재전송된 패킷3이 도착했을때 수신자는 패킷들의 순서를 정렬해야함<br>
</details>

<details markdown = "1">
<summary>전송계층이 제공하는 신뢰성 관련 기능 중, 혼잡제어에 대해 설명해주세요.</summary>
송신측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달됩니다. 만약 한 라우터에 데이터가 몰릴 경우, 자신에게 온 데이터를 모두 처리할 수 없게 됩니다.<br>
이 경우 호스트들은 또 다시 재전송을 하고 결국 혼잡만 가중시켜 오버플로우나 데이터 손실을 발생시키게 됩니다.<br>
따라서 이러한 네트워크 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송속도를 강제로 줄이게 되는데, 이러한 작업을 혼잡제어라고 합니다.<br>
(흐름 제어가 송신측과 수신측 사이의 전송속도를 다루는데 반해, 혼잡제어는 호스트와 라우터를 포함한 넓은 관점에서 전송 문제를 다룸)<br>
<br>
<br>
-- 답변은 이 형식 ---<br>
네트워크의 혼잡(네트워크 내에 패킷의 수가 과도하게 증가하는 현상)을 피하기 위해 송신측에서 보내는 데이터의 전송속도를 제어하는 것입니다.<br>
이러한 혼잡 현상을 방지하고 제거하기 위한 기능이 혼잡제어로 다양한 방식이 존재합니다.<br>
<br>

`AIMD(Additive Increase/ Multiplicative Decrease)` 방식은 처음에 패킷을 하나씩 보내고 문제가 없다면(ACK를 성공적으로 받으면) Window Size를 1씩 증가시키는 방식입니다.<br>
만약 문제가 발생하면 Window Size를 절반으로 줄입니다.<br>
초기에 높은 대역폭을 사용하지 못하여 오랜 시간이 걸리고 네트워크가 혼잡해지는 상황을 미리 감지하지 못합니다.<br>
<br>

`Slow Start` 방식도 앞선 AIMD와 마찬가지로, 패킷을 하나씩 보내면서 시작하며, ACK마다 윈도우 크기가 2배씩 증가하게 됩니다.<br>
윈도우 크기가 임계값에 도달하거나, 혼잡을 감지하면 윈도우 크기를 절반으로 줄이고 혼잡 회피 단계로 넘어가게 됩니다<br>
타임아웃이 발생하면 윈도우 크기를 1로 초기화하고 다시 Slow Start 단계를 시작합니다.<br>
<br>

`Fast Retransmit(빠른 재전송)`방식은 세개 이상의 중복된 ACK(동일한 ACK 번호)가 도착했을 때, 패킷 손실을 감지하는 메커니즘.<br>
일반적인 타임아웃을 기다리지 않고 즉시 해당 패킷을 재전송하게 됩니다.<br>
<br>
`Fast Recovery(빠른 회복)`방식은 빠른 재전송 후에 혼잡을 감지하면 윈도우 크기를 절반으로 줄입니다. 중복 ACK를 계속 수신하게 되면 윈도우 크기를 선형적으로 증가시킵니다<br>
</details>

<details markdown = "1">
<summary>DNS(Domain Name Server)이 무엇이죠?</summary>
도메인 이름과 IP주소와 도메인 이름 간의 변환을 도와주는 시스템을 의미합니다.<br>
</details>

<details markdown = "1">
<summary>www.google.com  도메인을 브라우저에 입력했을 때 일어나는 일을 순차적으로 설명해주세요.</summary>

1. 사용자가 브라우저의 주소창에 www.google.com을 입력합니다
2. 브라우저는 HSTS 목록을 조회하여 해당 URL이 HTTPS를 지원하는지 확인합니다. 지원한다면 요청은 HTTPS로 변환됩니다.
3. 브라우저는 이후 캐싱된 DNS 기록을 통해 통해 해당 도메인 주소에 대응하는 IP주소를 확인합니다.
4. 만약 요청한 URL에 대한 IP주소가 캐시에 없는 경우, ISP(인터넷 서비스 제공자)의 DNS 서버에 쿼리를 보내 호스팅하고 있는 서버의 IP주소를 찾습니다.
5. 브라우저는 해당 IP주소로 TCP연결을 시도합니다. 이 과정에서 3웨이 핸드쉐이크를 실행하여 서버와 연결을 확립합니다.
6. 연결이 완료되면 브라우저는 웹 서버에게 HTTP 요청 메세지를 생성하고 이를 전송합니다.
7. 서버는 받은 요청을 처리하고 해당 Response를 생성합니다.(HTTP 프로토콜을 활용해 메세지가 만들어짐)
8. 서버는 해당 응답 메세지를 TCP/IP연결을 통해 브라우저에 전송합니다.
9. 브라우저는 받은 응답을 렌더링하여 사용자에게 적잘한 형태로 화면에 출력합니다.
</details>

<details markdown = "1">
<summary>HOL 블로킹이란 무엇이며 HTTP에서는 이를 어떻게 해결하였나요??</summary>
HOL(Head-Of-Line)블로킹은 큐의 맨 앞에 있는 패킷이 처리 지연될 경우 그 뒤에 있는 패킷들도 같이 지연되는 현상을 의미합니다.<br>
HTTP(/2)에서는 이러한 문제를 해결하기 위해 MultiFlexing을 도입하였습니다.<br>
이는 하나의 연결에서 여러 요청과 응답 메세지를 동시에 처리할 수 있도록 하는 기술로, 각 요청과 응답은 별도의 스트림에서 처리되기 때문에, 하나의 스트림에서 지연이 발생하더라도 다른 스트림에는 영향을 미치지 않습니다.<br>
</details>

<details markdown = "1">
<summary>HTTP 통신과 소켓 통신의 차이점을 설명해주세요</summary>
소켓 통신은 서버와 클라이언트가 특정 포트를 통해 연결을 유지하고, 실시간으로 양방향 통신을 하는 방식으로 실시간으로 데이터를 주고 받는 경우에 사용됩니다.<br>
반면 HTTP 통신은 클라이언트가 요청을 보내는 경우에만 서버가 응답하는 단방향 통신입니다. 필요한 경우에만 서버로 접근하는 콘텐츠 위주의 데이터를 사용할때 용이합니다.<br>
</details>


<details markdown = "1">
<summary>TCP Connection시 3-way handshaking을 한다고 했는데, 이에 대해 설명해주세요.</summary>
3-way handshaking은 TCP에서 연결을 초기화하기 위한 과정입니다.<br>
우선 클라이언트가 서버에 연결 요청을 시작하기 위해 SYN 패킷을 보냅니다.(이 패킷에는 임의의 시퀀스 번호를 포함함)<br>
서버는 SYN 패킷을 받았음을 확인하기 위해 ACK를 보내고, 동시에 자신도 데이터를 보내기 위한 준비가 되었음을 알리기 위해 자신의 SYN 패킷을 보냅니다.<br>
클라이언트는 서버가 보낸 ACK와 SYN 패킷을 받고. ACK 패킷을 보내면서 연결 설정을 완료합니다.<br>
이 과정은 클라이언트와 서버 간에 안정적인 연결을 수립하고, 양쪽 모두 데이터 전송을 위한 준비가 되었음을 확인하기 위해 진행됩니다.<br>
<br>
참고 내용<br>
첫번째로 클라이언트는 서버에게 SYN 패킷을 보냅니다. 그리고 자신의 시퀀스 넘버 x를 보냅니다. 서버는 똑같이 SYN과 시퀀스 넘버 y를 보내고 패킷을 잘 받았다는 의미의 ACK=x+1을 보냅니다. 클라이언트는 응답을 받고 마지막으로 ACK=y+1을 보냅니다. 이 과정에서 클라이언트, 서버는 ACK를 받고 센더용 버퍼, 리시버용 버퍼를 생성하게 됩니다.<br>
</details>

<details markdown = "1">
<summary>4-way-handshaking에 대해 설명해주세요.(TCP 연결 해제 과정)</summary>
HTTP 요청과 응답 과정이 끝난 후, 연결 과정을 종료하는 4-way-handshaking이 진행됩니다.<br><br>

1. 클라이언트가 서버로 연결을 종료하겠다는(or 데이터 전송이 완료되었음을 서버에 알리기 위해) FIN 플래그가 설정된 패킷을 전송합니다.
2. 서버는 클라이언트에게 FIN 패킷을 받고,  응답하는 ACK를 보냅니다.(이 시점에서 서버는 클라이언트로부터 데이터 수신을 중단함.)
3. 서버가 보낼 데이터를 모두 전송한 후, 클라이언트에게 자신도 연결을 종료하려고 함을 알리기 위해 FIN 플래그가 설정된 패킷을 보냅니다.
4. 클라이언트는 서버가 보내온 FIN 패킷을 받고, 연결 종료에 대한 마지막 ACK 신호를 보냅니다.(이후 TCP 완전히 종료됨)

<br><br>
꼬리질문 1 - 4way가 한단계 더 많은 이유 or 해제시 사용 이유<br>
클라이언트가 서버에게 모든 데이터 요청을 보냈더라도, 서버 측에서는 클라이언트에게 아직 전송해야 할 데이터가 남아있을 수 있습니다. 따라서 서버는 데이터 전송을 완료한 후에야 FIN 메시지를 전송합니다. 이 과정을 통해 양측 모두가 데이터 전송을 완료하였음을 확인하고 연결을 안전하게 종료할 수 있습니다<br>
TCP는 양방향 통신이기에 송수신에 독립된 회선사용. 따라서 이에 대해 각각의 연결을 종료해야되기 떄문<br>

<br><br>
꼬리질문 2 - 그렇다면, Server가 Client에게 FIN 플래그를 전송하기 전에 전송한 패킷이 지연이나 유실로 인해 재전송이 일어나 FIN 패킷보다 늦게 도착하면 어떻게 처리를 하나요?<br>
이런 일을 방지하기 위해서, Server로부터 Client가 FIN 플래그를 받더라도 바로 세션을 종료시키지 않고 일정시간 잉여 패킷을 기다리는 과정을 거칩니다.<br>

<br><br>
꼬리질문 3 - 초기 Sequence Number인 ISM을 0부터 시작하지 않고 난수를 생성해서 설정하는 이유는???<br>
ISN을 난수로 시작하는 주된 이유는 보안과 관련이 있습니다. ISN이 예측 가능하면, 공격자가 이를 이용해 TCP 세션을 하이재킹하거나 다른 형태의 중간자 공격을 수행할 수 있습니다. 만약 ISN이 항상 0부터 시작한다면, 공격자는 이전 세션의 패킷과 현재 세션의 패킷을 혼란스럽게 만들 수 있어, 패킷 조작이나 재전송 공격이 가능해집니다<br>
<br>
커넥션을 맺을 때 사용하는 포트는 시간이 지남에 따라 재사용된다. 따라서 두 통신이 과거에 사용된 포트 번호 쌍을 사용할 가능성이 생기고 난수가 아닌 순차적 Number가 전송된다면 이전의 커넥션으로부터 오는 패킷으로 인식할 가능성이 생긴다<br>
</details>

<details markdown = "1">
<summary>포트와 소켓이 무엇인지에 대해 설명해주세요.</summary>

`포트`는 호스트 내에서 네트워크 통신을 하는 프로세스나 서비스를 식별하기 위한 고유한 번호입니다(0 ~ 65535, 보통 TCP,UDP에서 사용).<br>
이를 통해 하나의 IP 주소를 가진 컴퓨터에서도 여러 개의 서비스나 프로세스가 동시에 네트워크 통신을 할 수 있습니다.(ex: 웹서비스는 80, SSH는 22)<br>
(포트번호는 IP주소와 결합하여 송신 및 수신측 프로세스간의 통신을 가능하게함)<br>
<br>

`소켓`은 네트워크상에서 동작하는 프로그램 간 통신의 종착점으로, 두 시스템 사이의 네트워크 연결을 나타내는 객체입니다<br>
(IP 주소 + 포트 번호로 나타낼 수 있음, 이를 통해 네트워크 상 특정 컴퓨터의 프로세스나 서비스와 통신가능)<br>
소켓을 열기 위해서는(통신을 위해) IP, 포트 번호, 프로토콜이 필요하고, 송수신자 모두 소켓을 열어야 합니다.<br>
(특정 포트를 사용하여, 하나의 프로세스가 여러 개의 연결을 수립하려면 각 연결에 대해 고유한 소켓이 생성됩니다)<br>
<br><br>
포트는 특정 서비스나 프로세스가 네트워크상에서 통신하기 위한 끝점의 번호를 나타내며, 소켓은 실제 통신을 위한 양쪽 끝점을 의미합니다.<br>
</details>

<details markdown = "1">
<summary>TCP와 UDP가 무엇인지와 차이에 대해 설명해주세요.</summary>
<img src = "https://github.com/wookjongkim/cs-study/assets/121083077/a8d9b416-bff4-479a-848e-069b786a7214"> <br><br>

`TCP(Transmission Control Protocol)`은 신뢰성 있는 연결형 서비스를 지원하는 전송계층 프로토콜입니다.<br>
TCP는 연결 설정 및 해제를 위해 3 웨이 핸드쉐이크와 4웨이 핸드쉐이크를 사용하고, 순서대로 데이터를 전송하며, 중간에 유실되는 데이터는 재전송됩니다.<br>
흐름 제어, 혼잡 제어, 오류 제어등의 기능을 제공하고, 전이중 통신 방식을 사용하여 양방향으로 동시에 데이터 전송 이 가능합니다.(근데 전이중 통신은 TCP,UDP 둘다 가능함 답변시 빼야할듯)<br>
(점대점 방식으로 연결, 멀티캐스팅이나 브로드 캐스팅 지원 X)<br>
<br>
`UDP(User DataGram Protocol)`은 비연결형 서비스를 지원하는 전송계층 프로토콜 입니다.(최소한의 오류 검출 기능만 제공, 오류 복기 기능 X)<br>
tcp와 다르게 데이터의 전송 순서를 보장하지 않고, 수신 여부도 확인하지 않습니다.<br>
별도의 연결 과정을 진행하지 않고, Header 구성이 간단하여 전송 오버헤드가 적습니다.<br>
tcp보다는 빠른 전송 속도를 지원하므로, 스트리밍 서비스나, DNS 및 SNMP에 이용됩니다.<br>
(멀티 태스킹과 브로드 태스킹 지원)<br>
<br><br>
UDP와 TCP는 각각 독립된 포트 주소 공간을 가지므로, 동일한 포트 번호를 사용해도 충돌하지 않습니다.<br>
Checksum은 데이터와 헤더의 에러를 확인하는 용도로 사용됩니다. UDP의 헤더는 TCP에 비해 간단하므로, 오류 복구 기능이 불필요합니다.<br>
<br><br>
UDP가 TCP에 비해 갖는 장점<br>
- 연결 설정 및 해제 과정이 없어 시간 및 자원 소모 X
- 연결 상태를 저장하지 않기에 더많은 클라이언트 수용 가능(TCP는 연결 유지위해 송수신 버퍼, 각 파라미터 가지고 있어야)
- TCP는 20~60 바이트의 가변 헤더 크기를 가지지만, UDP는 8바이트로 고정<br>
- 패킷순서는 보장안되지만 데이터를 빠르게 전송 가능(흐름 제어를 안해서 빠르게 전송 가능, 재전송 순서보장등의 메커니즘이 없어서)
<br><br>
UDP에 체크섬 존재 이유 -> 오류 복구 기능은 없지만, 최소한의 오류 검출 기능을 제공하여 수신자가 패킷의 손상여부를 판단할 수 있게 하도록<br>
</details>

<details markdown = "1">
<summary>HTTP의 개념과 특징에 대해 설명해주세요.</summary>

`HTTP(HyperTesxt Transfer Protocol)`이란 인터넷에서 데이터를 주고 받는데 사용되는 프로토콜(통신 규약)로, 주로 웹 브라우저와 웹 서버간에 통신을 할때 사용됩니다.<br>
<br>

`비연결 지향(Connectionless)`: 클라이언트가 서버에 요청을 하면 서버는 해당 요청에 응답한 후 연결을 끊습니다. 이렇게 하면 많은 수의 사용자와 통신이 가능하게 됩니다.<br>
`상태 비저장(Stateless)`: 기본적인 HTTP는 서버가 클라이언트의 이전 상태나 정보를 저장하고 있지 않습니다. 즉, 각 요청은 독립적입니다. 이는 서버의 처리를 단순화시키지만, 상태를 유지해야 하는 웹 애플리케이션의 경우 쿠키나 세션 같은 기술을 사용하여 상태를 관리합니다.<br>
<br>
<img src = "https://github.com/wookjongkim/cs-study/assets/121083077/62139d0e-fda6-4f78-afef-456d48c45742">
<br>
</details>

<details markdown = "1">
<summary>HTTP와 HTTPS의 차이점에 대해 설명해주세요.</summary>
둘다 웹 브라우저와 서버 간의 데이터를 주고 받기 위한 프로토콜이지만, 몇가지 주요한 차이점이 있습니다.<br>
가장 큰 차이점은 보안 부분입니다. HTTP는 평문(plain text)로 자원을 주고 받기에 네트워크를 중간에서 탈취되면 그 내용을 쉽게 확인할 수 있습니다.<br>
반면 HTTPS는 SSL이나 TLS 프로토콜을 이용해  데이터를 암호화(공개키 방식)하여 (전송 계층에 전달)전송합니다.<br>
그리고 기본적으로 HTTP는 80포트를 사용하고, HTTPS는 443포트를 사용합니다.<br>
정리하자면 HTTPS는 HTTP에 비해 데이터 암호화 및 서버 인증 기능을 제공하여 통신의 보안을 강화합니다.<br>
<br>
참고 <br>
HTTPS는 암호화 복호화를 진행하기에, 이 과정에서 서버에 부하가 발생함.<br>
헤더는 그대로 두고, 바디 부분만 암호화함<br>
HTTPS는 대칭키 암호화와 비대칭키 암호화가 혼합되어 사용됨<br>
대칭키가 안전하게 교환된 후에는 대칭키를 사용하여 실제 데이터를 암호화및 복호화 수행<br>
<br>
꼬리질문 1 - HTTPS 통신 흐름에 대해 설명해주세요.<br>

1. 사용자가 브라우저를 통해 HTTPS 웹사이트에 접속하려하면, 우선 브라우저는 해당 서버에 요청을 보냅니다.
2. 서버는 클라이언트에게 자신의 디지털 인증서를 전송합니다. 이 인증서는 일반적으로 CA(Certificate Authority)라고 하는 신뢰할 수 있는 제3자 기관에 의해 발급되며, 서버의 공개키 및 정보, 인증서를 발급한 CA의 서명이 포함되어있습니다.
3. 클라이언트(웹 브라우저)는 서버로 부터 받은 인증서의 유효성과 신뢰도를 확인합니다. 이때 클라이언트는 이미 알고 있는 CA의 공개키를 사용해 인증서의 서명을 검증합니다. 인증서가 유효하다면 서버를 신뢰할 수 있는 것으로 판단합니다.
4. 클라이언트는 데이터 암호화를 위한 일회용의 대칭키(session key)를 생성합니다.
5. 클라이언트는 서버의 인증서에 포함된 공개키로 대칭키를 암호화하여 서버에 전송합니다.
6. 서버는 자신의 개인키를 사용해 암호화된 대칭키를 복호화합니다.
7. 이제 클라이언트 서버 모두 동일한 대칭키를 가지고 있기에, 이 키를 사용하여 암호화 및 복호화를 하면서 데이터를 교환합니다.
8. 통신이 끝나면 대칭키는 폐기되고, 다음 세션을 위해서는 새로운 대칭키가 생성됩니다.

<br>
꼬리질문 2 - HTTPS란 무엇인가요??<br>
HTTPS는 HTTP의 보안 버전입니다.HTTPS는 통신중에 정보가 인터셉트 되거나 조작되는 것을(중간자 공격) 막기 위해 SSL/TLS로 암호화하여 정보를 주고받습니다.<br>
</details>

<details markdown = "1">
<summary>SSL 프로토콜에 대해 설명해주세요.</summary>
SSL(Secure Socket layer)는 웹 상에서 데이터를 암호화하여 전송하는 프로토콜입니다. 이는 사용자와 서버 간의 정보가 중간에서 공격자에 의해 도청되거나 변조되는 것을 방지하기 위해 설계되었습니다.<br>
<br>
참고 : 작동방식<br>
<br>

1. 클라이언트와 서버가 핸드쉐이크 과정을 통해 통신을 시작함.<br>
2. 이 과정에서 양쪽은 암호화에 사용될 키를 교환하며, 이후의 통신은 이 키를 사용해 암호화되어 진행됨.
3. 암호화된 데이터가 목적지에 도착하면, 수신 측에서는 미리 공유된 키를 사용해 데이터를 복호화하여 원래의 내용을 얻습니다.
<br>
후속 버전으로 TLS
</details>

<details markdown = "1">
<summary>HTTP 메서드에 대해 설명해주세요.</summary>
HTTP Method는 HTTP 요청의 종류를 나타내며, 서버가 클라이언트에게 요청을 어떻게 응답해야 할지를 알려줍니다(요청의 목적을 나타냄).<br>
이러한 HTTP Method에는 크게 GET, POST, PUT, PATCH,DELETE 등이 있습니다.<br>
<br>

`GET`은 주로 리소스(서버에 저장된 데이터) 조회에 사용됩니다. 이때 클라이언트가 서버로 데이터를 전달하고자 한다면 URL의 쿼리 파라미터를 통해 전달합니다.<br>
`POST`는 서버에 새로운 데이터를 등록하거나 서버에서의 특정 작업을 수행하기 위해 사용됩니다. POST의 경우 메시지 바디를 통해 데이터를 전송합니다.(민감한 정보 전달이나 복잡한 구조에 적합, 멱등성 보장 안됨)<br>
`PUT`은 리소스의 생성 또는 수정을 위해 사용됩니다. 지정된 URI에 리소스가 존재하면 덮어씌우고, 엎으면 새로 생성합니다.(멱등성 보장)<br>
`PATCH`는 리소스의 부분적인 수정을 위해 사용됩니다. (일반적으로는 멱등성이 보장안됨. 그러나 구체적인 동작은 API 디자인 및 구현에 따라 다름)<br>
`DELETE`는 지정된 URI의 리소스 삭제를 위해 사용됩니다.(멱등성 보장됨)
<br><br>
참고 - HTTP 메세지 내용은 보통 ASCII로 인코딩된 텍스트 정보로 구성되어있음
</details>

<details markdown = "1">
<summary>HTTP 상태 코드들에 대해서 설명해주세요.</summary>
HTTP 상태 코드란 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능을 하는 코드로, 숫자의 첫번째 자리에 따라 5개의 범주로 나눌 수 있습니다.<br>

- 백번 대(1xx : informational)는 요청이 수신되어 처리 중임을 의미합니다.
- 이백번대(2xx : successful)은 요청이 정상 처리되었음을 나타냅니다.
- 삼백번대(3xx : redirection)은 클라이언트에게 다른 위치로의 리다이렉션 또는 추가 동작이 필요함을 의미합니다(Location 헤더 사용).
- 사백번대(4xx : client error)는 클라이언트쪽의 요청에 문제가 있음을 나타냅니다.
- 오백번대(5xx : server error)는 서버 측의 문제로 인해 요청이 완료되지 않았음을 의미합니다.

<br><br>
201 Created -> Post로 뭔가 등록한 경우<br>
202 Accepted -> 요청이 접수되었으나 처리가 완료되지 않음(ex: 1시간 후 배치 동작)<br>
204 No Content는 서버가 요청을 성공적으로 수행했지만, 응답 페이로드에 보낼 데이터가 없는 경우<br>
<br>
301, 308 -> 리소스의 uri가 영구적으로 이동한 경우<br>
304 Not Modified는 클라이언트의 캐시된 버전이 유효한경우 서버가 반환하는 상태코드<br>
<br>
400 -> 잘못된 요청으로 서버 요청 처리 불가<br>
401 Unauthorized -> 클라이언트가 해당 리소스에 대한 인증이 필요할때<br>
403 Forbidden은 주로 인증 자격은 있지만, 접근 권한이 불충분한 경우 발생합니다.<br>
404 Not Found는 서버가 요청한 리소스 찾을수 없을때<br>
<br>

<br>

</details>

<details markdown = "1">
<summary>GET과 POST의 차이점에 대해 설명해주세요</summary>
우선 두 메서드는 사용 목적이 다릅니다.<br>
GET은 주로 서버의 리소스를 조회하는데 사용되는 반면(서버 영향 X), POST는 서버의 자원을 생성하거나 변경하는데 사용됩니다(서버 영향 O).<br>
그리고 GET은 주로 URL의 쿼리스트링에 데이터를 포함하지만, POST의 경우 주로 HTTP 메세지의 바디 부분에 포함시킵니다.<br>
GET은 멱등성을 가지기 떄문에 동일한 요청을 여러번 전송해도 동일한 결과가 반환됩니다. 이러한 특성 덕분에 캐싱에 적합합니다.<br>
반면 POST는 멱등성을 가지지 않습니다. 즉 같은 요청을 여러번 전송하더라도 결과가 달라질수있습니다. 따라서 캐싱에 적합하지 않습니다.<br>
<br>
참고 - GET은 주로 url 길이에 제한된 적은 양의 데이터만 전송됨, POST는 대용량 데이터를 전송하는데 적합(ex: 이미지, 동영상 등등)<br>
캐시를 사용하여 서버 부하 늦출수 있다, 만약 요청이 멱등성을 가지지 않는다면, 동일한 요청에 대해 다른 결과가 반환될 가능성이 있습니다.<br>
</details>

<details markdown = "1">
<summary>POST와 PUT의 차이점에 대해 말씀해주세요</summary>
POST 메서드의 경우 리소스를 생성할때 클라이언트가 그 경로를 직접 지정하지 않습니다. 대신 서버가 생성된 리소스의 URI를 응답 메세지의 Location 헤더를 통해 알려줍니다.<br>
반면 PUT은 리소스를 생성하거나 업데이트할때 그 경로를 직접 지정합니다.PUT은 특정 리소스에 대한 전체 업데이트를 의미하기 떄문입니다.<br>
<br>
POST는 멱등하지 않고 PUT은 멱등함<br>
</details>

<details markdown = "1">
<summary>PUT과 PATCH의 차이점에 대해 말씀해주세요</summary>
PUT과 PATCH는 모두 리소스를 수정하는데 사용되는 HTTP 메서드입니다.<br>
하지만 PUT 메서드는 리소스 전체를 업데이트하기 위해 사용됩니다. 예를들어, 리소스의 모든 필드를 새값으로 대처할때 PUT을 사용하게 됩니다.(만약 일부 필드만 제공되면, 누락된 필드는 null이나 기본값)<br>
반면 PATCH 메서드는 리소스의 일부만을 수정하기 위해 설계되어있습니다.<br>
그리고 보통 PUT은 멱등하게, PATCH는 멱등하지 않게 설계합니다.(절대적 기준은 아니고 설계에 따라 달라짐)<br>
<br>
<img src = "https://github.com/wookjongkim/cs-study/assets/121083077/b36dd796-e597-4b2d-8408-2fd18e1d0223">
</details>

<details markdown = "1">
<summary>멱등성(idempotent)이 무엇인가요?</summary>
멱등성이란 동일한 요청을 여러 번 보내더라도 서버상의 결과(리스폰스라기 보다는 자원의 상태나 변화를 의미)가 바뀌지 않는 것을 의미합니다.<br>
(ex: 요청에 따라 데이터베이스 내의 특정 데이터가 변경되거나, 파일이 생성/삭제되는 경우 지칭, 동일한 멱등 요청이 여러번 전송될 경우 서버의 자우너 상태는 처음 요청을 처리한 후의 상태와 동일하게 유지됨)<br>
<br>
GET,PUT,DELETE는 멱등성 메소드에 속하고, POST는 멱등성 메소드가 아님<br>
예를들어, 게시글 작성이나 댓글 추가와 같은 연산에서 POST 요청을 여러번 보내면, 중복된 게시글이나 댓글이 생성될 수 있습니다.<br>
GET은 여러 번 수행해도 서버의 상태가 변하지도 않고 같은 결과를 가져온다.<br>
PUT은 여러 번 수행해도 결과적으로 데이터는 요청한 값으로 수정된 항상 같은 상태이다.<br>
DELETE도 여러 번 수행해도 이미 존재하든, 존재하지 않든 그 데이터는 DELETE 요청을 보낸 시점에 사라진다.<br>
PATCH의 멱등성은 구현에 따라 달라질수있음.<br>
<br>
추가 질문1 - safe라는 개념은 무엇인가?<br>
safe는 서버에 있는 자원에 대해 읽기만 수행하고, 그 자원의 상태나 값을 변경하지 않는 다는 것을 의미, 대표적으로 GET 메서드가 있음<br>
</details>

<details markdown = "1">
<summary>HTTP의 Keep-alive 헤더에 대해 설명해주세요.</summary>
HTTP의 Keep-alive 헤더는 지속적인 연결(persistent connection)을 관리하기 위한 헤더입니다.<br>
HTTP/1.0에서는 기본적으로 연결이 비 지속적이였기에, 클라이언트와 서버간의 각 요청 및 응답 이후 연결이 종료되었습니다.이로 인해 매번 새로운 연결을 생성하는 오버헤드가 발생하였습니다.<br>
Keep alive 헤더를 사용하면, 클라이언트와 서버는 현재 연결을 유지하면서 여러번의 요청과 응답을 주고 받을 수 있습니다.<br>
이로 인해 연결 설정 오버헤드를 줄이고, 더 빠른 응답시간을 얻을 수 있는 장점을 제공합니다.<br>
<br>
HTTP/1.1에서는 연결이 기본적으로 지속적입니다. 그러므로 HTTP/1.1에서는 지속적인 연결을 사용하려면 별도의 Keep-Alive 헤더를 지정할 필요가 없습니다. 그러나 연결을 비지속적으로 변경하려면 Connection: close 헤더를 사용해야 합니다.<br>
</details>

<details markdown = "1">
<summary>HTTP 1.0과 1.1 차이에 대해 설명해주세요</summary>
<img src = "https://github.com/wookjongkim/cs-study/assets/121083077/7643d6ff-f10d-46ad-93e7-b8a5d9c2cc1d">
<br>
HTTP 1.0은 기본적으로 비지속적 연결을 사용합니다.<br>
클라이언트가 서버에 요청을 보낼때마다 새로운 TCP 커넥션을 생성하고, 응답을 받은 후 해당 커넥션을 종료합니다. 이로 인해 각 요청에 대한 연결 설정과 종료의 오버헤드가 발생되어 비효율적입니다.<br>
(Keep-alive 헤더를 사용하여 연결을 지속적으로 유지할순 있지만 표준이 아니였음.)<br>
반면 HTTP 1.1은 지속적 연결이 기본입니다. 따라서 클라이언트와 서버는 현재 연결을 유지하면서 여러번의 요청과 응답을 교환할 수 있게 됩니다.<br>
<br>
그리고 HTTP 1.0은 요청과 응답이 순차적으로 진행됩니다.(즉 첫번째 요청이 응답을 받아야지만 두번쨰 요청을 할 수 있습니다)<br>
하지만 HTTP 1.1은 파이프라이닝 기능을 통해 클라이언트는 여러 요청을 연속적으로 보낼 수 있습니다.<br>
하지만 서버는 여전히 응답을 순차적으로 처리하며, 이로 인해 첫번째 요청에서 발생한 지연이 후속 요청의 처리를 지연시킬 수 있습니다(HOL : Head of Line Blocking 문제)<br>
<br>
참고 - 이거 말고도 호스트 이름을 기반으로 여러 도메인을 하나의 IP 주소에 호스팅할 수 있게 해주는 Host 헤더를 도입하였습니다.<br>
</details>

<details markdown = "1">
<summary>HTTP 2.0의 특징에 대해 설명해주세요</summary>
HTTP 2.0에서는 멀티플렉싱, 헤더 압축, 서버 푸시를 지원하는 프로토콜입니다.<br>
<br>

`멀티플렉싱`은 여러개의 스트림을 사용하여 송수신을 합니다. 이를 통해 특정 스트림의 패킷이 손실되었다 하더라도 해당 스트림에만 영향을 미치고 나머지 스트림에는 영향을 미치지 않습니다.<br>
그리고 병렬로 여러 요청을 받을 수 있고, 응답을 줄수 있습니다.(가장 빨리 처리된 응답부터 클라이언트에게 전달)<br>
<br>
HTTP 1.1에서는 매 요청마다 반복되는 헤더 정보가 포함되어 비효율적이였습니다. 이를 위해 HTTP 2.0에서는 허프만 코딩이라는 특별한 알고리즘을 사용하여 헤더를 압축함으로서 전송 데이터의 크기를 줄입니다.(네트워크 대역폭 절약, 성능 향상)<br>
<br>
또한 서버 푸시를 통해 서버는 클라이언트가 요청하기 전에 필요한 리소스를 미리 푸시할 수 있습니다.<br>
ex) 예를 들어, HTML 문서를 요청했을 때 필요한 CSS나 자바스크립트 파일을 클라이언트가 별도로 요청하지 않아도 미리 전송해줄 수 있습니다<br>
<br>
참고 - 허프만 코딩은 문자열을 문자 단위로 쪼개 빈도수를 세어 빈도가 높은 정보는 적은 비트수를 사용하여 표현하고, 빈도가 낮은 정보는 비트수를 많이 사용하여 표현해서 전체 데이터의 표현에 필요한 비트양을 줄이는 원리<br>
병렬 -> 여러 작업을 동시에 처리한다는 것<br>
</details>

<details markdown = "1">
<summary>CORS(Cross Origin Resource Sharing)가 무엇인지 설명해주세요.</summary>
CORS는 추가적인 HTTP 헤더를 사용하여, 한 오리진(프로토콜 + 도메인 + 포트번호)에서 실행 중인 웹페이지가 다른 오리진의 (선택한) 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 메커니즘입니다.<br>
<br>
기본적으로 웹 브라우저의 보안 정책으로 인해 한 오리진에서 호스팅되는 웹페이지를 다른 오리진의 리소스에 직접 접근할 수 없습니다. 그러나 웹 애플리케이션에서는 종종 다른 오리진의 리소스에 접근해야할 필요가 있습니다.<br>
<br>
CORS는 서버 측에서 응답에 (Access-control-allow-origin)특별한 헤더를 포함시켜, 특정 출처의 애플리케이션이 자원에 접근할 수 있도록 허용할지를 지정할 수 있게 됩니다.<br>
결과적으로, CORS는 안전하게 다른 오리진의 리소스와 상호작용할 수 있게 하는 보안 표준입니다.<br>
<br>
<img src = "https://github.com/wookjongkim/cs-study/assets/121083077/f3c7f2ab-694c-42bc-add4-391cbd170cd6">
</details>

<details markdown = "1">
<summary>REST API가 무엇인가요? RESTFUL이 무엇인가요?</summary>
(이걸 통해 백과 프론트 통신함)<br>
<br>
REST API는 REST 원칙에 따라 서비스 API를 구현한 것입니다.<br>
여기서 REST는 자원의 표현, 즉 이름(URI)으로부터 자원의 정보를 주고받는 것을 의미합니다.<br>
따라서 자원을 uri로 표현하고 자원에 대한 행위는 HTTP 메서드로 표현한것이 REST API의 핵심입니다.<br>
<br>
RESTFUL이라는 것은 REST 원칙을 잘 따르는 시스템을 의미합니다.<br>
자원은 uri로 나타내고, 행위에 맞는 적절한 HTTP 메서드를 사용한 것이 RestFul한 API라고 할 수 있습니다.<br>
<br>
RESTFUL 하지 않은 경우를 예로 들자면, CRUD 기능을 모두 POST로만 처리한 것을 RESTFUL 하지 않다고 말할 수 있습니다.(URL에 동사를 사용한 경우 포함)<br>
<br>
참고<br>
URI는 Uniform Resource Identifier의 약자로, 인터넷 상의 자원을 고유하기 식별하거나 이름을 부여하는데 사용된 문자열을 말합니다.<br>
URI는 URL을 포괄하는 더 큰 범주, 모든 URL는 URI<br>
REST는 HTTP 프로토콜을 기반으로 동작하기 때문에, HTTP의 특징들을 그대로 활용할 수 있습니다. 예를 들어, 무상태성을 활용하여 클라이언트와 서버 간의 상호작용이 독립적으로 유지되거나, 캐시 기능을 사용하여 효율적인 데이터 처리가 가능합니다.<br>
</details>

<details markdown = "1">
<summary>쿠키와 세션이 무엇이죠?</summary>
기본적으로 HTTP 프로토콜은 connectionless(비연결형), stateless(무상태)한 특성을 가지기 때문에 서버는 클라이언트가 누구인지 매번 확인하는 절차가 필요했습니다.<br>
이러한 단점을 보완하는 것이 쿠키와 세션입니다.<br>
<br>
쿠키는 클라이언트 측에 저장되는 작은 텍스트 파일입니다.<br>
서버에서 HTTP 응답 헤더를 통해 클라이언트에게 쿠키를 전송하고, 클라이언트는 다시 해당 서버에 요청을 보낼 때 HTTP 요청 헤더에 저장된 쿠키를 포함하여 전송합니다.<br>
그리고 이후에 같은 서버로 요청을 보낼때마다, 쿠키를 서버로 함께 전송하게 됩니다.<br>
<br>
세션은 서버 측에서 클라이언트의 상태를 유지하기 위한 기술입니다.<br>
클라이언트가 서버에 요청을 보내면(ex: 로그인 요청), 서버는 클라이언트에게 세션 ID를 부여하고, 해당 세션 ID에 대한 정보를 서버 측에서 유지합니다.<br>
이후 클라이언트가 서버에 요청을 보낼때 마다, 세션 ID를 함께 전송하고, 서버는 이를 통해 클라이언트의 상태를 식별합니다.<br>
<br><br>
참고 - 보통 두개 같이 사용함<br>
키는 만료 시간 부여하고, 세션은 브라우저 종료 시 소멸되는 특성(이거 보다는 보통 일정 시간동안 유지되고, 그 시간동안 사용자가 다시 요청 안보내면 세션을 만료될 수 있음)<br>
세션은 서버의 자원을 사용하기 때문에 사용자가 많을 수록 소모되는 자원이 많기 때문에 상황을 잘 고려해서 사용해야 한다.<br>
쿠키는 클라이언트 측에 저장되므로, 쉽게 접근 가능. 만약 암호화 안하고 중요한 정보가 저장되면 위험함<br>
쿠키는 HTTP 통해 전송되며, HTTPS 사용안하면 중간자 공격(트래픽을 도청하여 쿠키 내용 캡쳐)에 취약<br>
XSS는 악의적인 스크립트를 애플리케이션에 삽입하여 실행되게 하는 공격. 이를 통해 공격자는 사용자 쿠키에 접근 가능<br>
CSRF(크로스 사이트 요청 위조) : 사용자가 자신의 의지와는 무관하게 악의적 요청을 웹에 보내게 만드는 기술.(여기에 종종 사용자 쿠키가 이용됨)<br>
</details>

<details markdown = "1">
<summary>쿠키와 세션을 이용하여 로그인하는 과정을 설명해주세요</summary>

1. 사용자가 로그인 정보를 입력 후 로그인 요청을 합니다.
2. 서버는 입력받은 로그인 정보가 유효하다면, 사용자에 대한 세션을 생성합니다. 이 세션에는 사용자 식별 정보와 다른 필요한 데이터들이 저장됨
3. 서버는 생성한 세션의 ID를 응답 헤더에 포함시켜 사용자의 웹에 전송합니다.
4. 브라우저는 받은 세션ID를 쿠키에 저장합니다(세션 쿠키라고도 함).
5. 이후 사용자가 다른 페이지를 요청할 때마다 브라우저는 세션 ID가 저장된 쿠키를 서버로 함께 전송합니다.
6. 서버는 전송받은 세션 ID를 이용하여 세션 저장소에서 사용자의 세션을 찾아냅니다. 이를 통해 사용자가 로그인 상태임을 확인합니다.(특화된 정보나 서비스 제공)

</details>

<details markdown = "1">
<summary>만약 session의 값을 가져오는 key를 "user"라고 합시다, 사용자 A가 접속해도, B가 접속해도 "user"라는 key를 통해 가져오는데 어떻게 각각 다른 결과 값을 받을 수 있는지 설명해주세요.</summary>
서버는 세션을 생성할때 그에 대응하는 고유한 세션 ID를 만들고 이는 클라이언트의 브라우저에게 전송됩니다.<br>
즉 각 클라이언트마다 고유한 세션 아이디가 있고, 이는 서버상의 각각의 세션 객체와 연결되어있습니다.<br>
이러한 방식으로, 서버는 여러 클라이언트의 상태를 독립적으로 관리하게 됩니다<br>
<br>
유사질문<br>
세션은 서버에 저장되고, 쿠키는 클라이언트에 저장된다고 하셨는데, 그럼 쿠키가 안되는 상황에서도 세션은 사용할 수 있나요?<br>
쿠키를 사용할 수 없을 때는 url 뒤쪽에 파라미터 값으로 전달하는 경우가 있다.<br>
</details>

<details markdown = "1">
<summary>JWT에 대해 설명해주세요.</summary>
JWT(Json Web Token)란 JSON형식의 웹토큰으로 클라이언트와 서버 사이에서 인증 및 권한 부여 작업을 수행할 수 있습니다.<br>
JWT는 Header, Payload, Signature로 구성되어있습니다.<br>

`Header`에는 토큰의 유형(ex: JWT)과 사용된 서명 알고리즘(ex: RSA, SHA256)과 같은 메타데이터 정보를 담고있습니다.<br>
`Payload`에는 토큰에서 사용할 정보의 조각들인 Claim(등록된, 공개, 비공개로 나뉨, 키 : 값 형태)이 담겨있습니다.클레임에는 사용자 식별을 위한 고유 ID와 같은 정보들이 담겨있습니다.<br>
`Signature`은 토큰을 인코딩하거나 유효성 검증을 할때 사용하는 고유한 암호화 코드입니다.<br>
사용자가 로그인 요청을 할 때, 서버는 사용자의 인증을 확인하고 JWT를 생성하여 클라이언트에게 반환합니다. 클라이언트는 이후 요청마다 JWT를 포함하여 서버에 전송하고, 서버는 Signature 부분을 검증하여 토큰의 유효성 및 무결성을 확인합니다.<br>
<br>
단점들<br>
페이로드 자체는 암호화된 것이 아니라 BASE64로 인코딩 된 것이다. 중간에 Payload를 탈취하여 디코딩하면 데이터를 볼 수 있으므로 JWE로 암호화하거나 Payload에 중요한 데이터를 넣지 않아야한다.<br>
Stateless : JWT는 상태를 저장하지 않기 때문에 한번 만들어지면 제어가 불가능하다. 즉, 토큰을 임의로 삭제하는 것이 불가능하므로 토큰 만료시간을 꼭 넣어주어야한다.<br>
<br>
주의점<br>
탈취에 의해 악의적으로 사용될 가능성이 있기에 보통 유효시간을 짧게 가져가고 Refresh 토큰을 사용하는 방식으로 구현한다<br>
</details>

<details markdown = "1">
<summary>JWT를 이용하여 로그인 하는 과정을 설명해주세요</summary>

1. 클라이언트가 로그인 페이지에 접속하여 로그인 정보를 입력합니다.
2. 서버는 입력받은 로그인 정보를 인증하고, 로그인에 성공하면 해당 사용자 정보를 기반으로 JWT를 생성합니다.
3. 서버는 생성된 JWT를 클라이언트에게 전송합니다.
4. 클라이언트는 전송받은 JWT를 저장합니다.
5. 이후 클라이언트가 서버에 요청을 보낼때마다, JWT를 HTTP 헤더에 포함하여 전송합니다.
6. 서버는 전송받은 JWT를 이용하여 해당 사용자를 인증하고, 요청을 처리합니다.

</details>

<details markdown = "1">
<summary>JWT 리프레쉬 토큰에 대해 설명해주세요.</summary>
JWT의 refresh token은 클라이언트에게 주어진 긴 유효기간을 가진 토큰입니다.<br>
기본적인 JWT 토큰의 유효기간은 짧게 설정되는 경우가 많아, 유효 기간이 지나면 클라이언트는 이 refresh token을 사용하여 새로운 access token을 서버에 요청할 수 있습니다.<br>
이 방식을 사용하면 사용자가 자주 로그인해야 하는 번거로움을 줄이면서, 짧은 유효기간의 access token을 사용함으로서 보안을 강화할 수 있습니다.<br>
<br>
참고<br>
만약 refresh token이 노출되거나 유출된다면, 이 token으로 새로운 access token을 발급받을 수 있기 때문에 보안 관리가 중요합니다.<br>
</details>

<details markdown = "1">
<summary>URI와 URL의 차이점에 대해 설명해주세요</summary>
URL(Uniform Resource Locator)은 인터넷상의 자원의 위치를 의미합니다.<br>
URI(Identifier)는 인터넷 상의 자원을 식별하기 위한 문자열의 구성으로, URI는 URL과 URN 포함<br> 
</details>

---
## 기타 질문들

<details markdown = "1">
<summary>Blocking/Non-Blocking과 Synchronous/Asynchronous</summary>
Blocking은 호출된 함수가 자신의 작업이 완료될떄까지 제어권을 반환하지 않아서, 호출한 함수가 대기 상태에 있게 되는 방식을 뜻합니다. 즉, 해당 작업이 끝날때까지 다른 작업을 진행할 수 없습니다.<br>
Non Blocking은 호출된 함수가 자신의 작업을 즉시 완료할 수 없더라도, 제어권을 즉시 반환하여 호출한 함수가 다른 작업을 계속 진행할 수 있게 하는 방식을 의미합니다.<br>
<br>
동기는 작업을 수행할때, 해당 작업이 완료될떄까지 다른 작업을 수행하지 않는 방식입니다. 즉, 한 작업이 완료된 후에 다음 작업이 실행됩니다.<br>
비동기는 한 작업을 시작하고 완료를 기다리지 않고 바로 다음 작업을 시작하는 방식입니다. 콜백, 프로미스, 이벤트 리스너등의 메커니즘을 통해 완료시점을 알림<br>
<br>
간단하게 말하면, Blocking/Non-Blocking은 작업이 완료될 때까지 기다리느냐 아니냐에 관한 것이고, Synchronous/Asynchronous는 작업을 수행하는 방식이 순차적으로 진행되느냐 동시에 여러 작업이 진행되느냐에 관한 것입니다.<br>
</details>

<details markdown = "1">
<summary>네트워크의 전체 흐름을 설명해보세요.</summary>

- 응용 계층에서 HTTP 메세지를 보냄
- 전송 계층으로 이 데이터가 전달되고, 여기서 TCP 헤더가 붙어 세그먼트가 됨. TCP 헤더에는 어느 애플리케이션에 데이터를 보내야할지 담겨 있음. 출발지 번호와 목적지 포트 번호가 그역할. 출발지 포트 번호는 잘알려진 포트가 아닌 포트 중에서(1025 이상) 무작위로 선택됨. 목적지 포트는 HTTP라 80선택
- 네트워크 계층으로 세그먼트 데이터가 전달되고, 여기서 IP헤더가 붙음. IP헤더에 출발지 컴퓨터와 목적지 서버의 위치가 각각 출발지 IP주소, 목적지 IP 주소 형태로 추가됨. IP헤더가 붙은 데이터를 IP 패킷이라 함.
- 데이터 링크 계층으로 IP 패킷이 전달됨, 여기서 이더넷 헤더가 붙음. 이더넷 헤더가 붙은 데이터를 이더넷 프레임이라고 부름
- 물리계층으로 이더넷 프레임이 전달되고, 이 데이터가 전기 신호로 변환되어(랜 카드를 통해) 네트워크로 전송됨

</details>

<details markdown = "1">
<summary>대칭키, 비대칭키 암호화 방식에 대해 설명해주세요.</summary>
대칭키 암호화와 복호화에 같은 키를 사용하는 방법입니다.<br>
비대칭키는 암호화와 복호화에 서로 다른 키를 사용하는 방법입니다.<br>
타인에게 노출되어서는 안되는 개인키(private key)와 공개적으로 개방되어있는 공개키가 쌍을 이룬 방식입니다.<br>
<br>
공개키 -> 암호화에 사용, 개인키는 데이터 복호화에 사용됨<br>
</details>

<details markdown = "1">
<summary>공인(public) IP와 사설(private) IP의 차이에 대해 설명해주세요</summary>
공인 IP는 ISP(인터넷 서비스 공급자)가 제공하는 IP 주소이며, 외부에 공개되어 있습니다.<br>
사설 IP는 일반 가정이나 회사 내 등에 할당된 네트워크 IP 주소이며, IPv4의 주소부족으로 인해 서브넷팅된 IP이기 떄문에 라우터(공유기)에 의해 로컬 네트워크상의 PC나 장치에 할당됩니다.<br>
</details>

<details markdown = "1">
<summary>라우터란 무엇이죠?</summary>
라우터는 네트워크에서 데이터 패킷의 전송을 중개하는 장치입니다.<br>
라우터는 네트워크 내에서 패킷을 수신하면 해당 패킷의 목적지 주소를 확인합니다. 이후 포워딩 테이블이라는 내부 정보를 참조하여 패킷을 올바른 목적지로 전송합니다.(포워딩 테이블)<br>
라우팅은 라우터가 네트워크 구조를 이해하고, 최적의 경로를 결정하여 포워딩 테이블을 생성 및 유지하는 과정을 의미합니다. 이를 통해 라우터는 다양한 경로 중 가장 효율적인 경로로 데이터 패킷을 전송합니다.<br>
</details>

<details markdown = "1">
<summary>IP와 IP 주소에 대해 설명해주세요.</summary>
IP는 인터넷 프로토콜의 약자로, 컴퓨터 네트워크에서 데이터를 패킷 형태로(분할하여) 전송하는 규약입니다.<br>
IP주소는 인터넷 상에서 컴퓨터나 네트워크 장비가 유일하게 식별될 수 있도록 부여하는 주소입니다.<br>
가장 널리 사용되는 IPV4는 32비트 주소체제를 사용하고, 8비트씩 끊어서 10진수로 나타냅니다.
IP주소는 크게 네트워크 ID(서브넷 ID)와 호스트 ID로 구분됩니다. 이 둘은 서브넷 마스크를 통해 구분되며, 네트워크의 구조나 규모에 따라 유동적으로 할당 될 수 있습니다.<br>
초기에는 Class A, B, C와 같은 방식으로 IP 주소를 구분하였으나, 최근에는 CIDR(Classless Inter-Domain Routing) 방식을 사용하여 보다 유연하게 주소를 할당하고 관리하게 되었습니다<br>
<br>
`서브넷 마스크` : IP주소의 네트워크 부분과 호스트 부분을 구분하는데 사용<br>
</details>

<details markdown = "1">
<summary>NAT(Network Address Translation)이 무엇이죠?</summary>
개인 네트워크의 IP주소를 인터넷에 연결될 때 공용 IP 주소로 변환하는 기술입니다.<br>
주로 가정이나 기업 내부 네트워크에서 사용하는 사설 IP 주소를 외부 인터넷으로 나갈때 공인 IP주소로 매핑하여 통신이 가능하게 합니다.<br>
이를 통해 IP 주소 부족 문제를 완화하고 보안을 강화할 수 있습니다.<br>
</details>

<details markdown = "1">
<summary>이더넷이 무엇이죠?</summary>
컴퓨터 네트워크 기술의 일종으로 LAN에서 가장 많이 활용되는 네트워크 규칙입니다.<br>
이러한 이더넷에서는 CSMA/CD라는 프로토콜을 사용합니다.<br>
<br>
꼬리질문 1 - CSMA/CD가 뭐죠?<br>
이더넷 네트워크에서 데이터 충돌을 감지하고 관리하기 위한 프로토콜입니다.<br>
만약 두 장치가 동시에 데이터를 전송하게 되면 충돌이 감지되고, 감지된 후에 해당 장치들은 임의의 시간을 기다린 후 다시 전송을 시도합니다.<br>
<br>
꼬리질문 2 - ARP가 무엇이죠?<br>
ARP는 IP주소를 통해 해당하는 MAC 주소를 찾아내는 프로토콜입니다.<br>
</details>

<details markdown = "1">
<summary>MAC(Media Access Control)주소는 무엇이죠?</summary>
MAC주소는 네트워크 하드웨어 장치(이더넷 카드, 와이파이 카드 등)의 고유한 식별자로, 6바이트(48비트)로 구성됩니다.<br>
(일반적으로 16진수 표기법으로 표현됨, ex) 00:1A:2B:3C:4D:5E)<br>
네트워크 환경에서 장치들 간의 통신을 할 때, 각 장치를 구분하기 위한 고유한 식별자가 필요합니다. IP 주소도 이런 식별 역할을 합니다만, IP 주소는 동적으로 변경될 수 있습니다. 반면, MAC 주소는 해당 장치의 하드웨어에 내장되어 있으므로 변경되지 않아, 안정적인 식별이 가능합니다.<br>
</details>

<details markdown = "1">
<summary>스위치는 무슨 기능을 하나요?</summary>
스위치는 LAN 내의 기기들을 연결해주고, 패킷이 서로 충돌없이 원하는 곳에 잘 도착할 수 있도록 도와줍니다.<br>
스위치 안에는 스위치 테이블이 존재하여 연결된 인터페이스들의 맥주소와 연결된 포트 번호를 담고있습니다.<br>
스위치는 데이터 링크 계층에서만 동작하기 떄문에 라우팅 같은 기능은 할 수 없습니다.<br>
</details>

<details markdown = "1">
<summary>방화벽에 대해 설명해주세요.</summary>
방화벽은 수신 및 발신 네트워크 트래픽을 모니터링하고, 정의된 보안 규칙을 기준으로 하여 특정 트래픽의 허용 또는 차단을 결정하는 네트워크 보안 디바이스 입니다.<br>
</details>

<details markdown = "1">
<summary>브루트 포스 공격이란 무엇인지 설명해주세요.</summary>
브루트포스(brute force)라는 의미 그대로 무차별 대입 공격을 말합니다.
브루트포스 공격 대상은 다양하지만 주로 시스템을 이용할 때 필요한 비밀번호나 암호키입니다.
이러한 공격에 대비하기 위해 비밀번호로 설정 가능한 조합의 수를 늘려 풀 수 있는 시간을 늘리는 수 밖에 없습니다.
모든 경우의 수를 대입하기 때문에 이론적으로 풀 수 없는 암호는 존재하지 않기때문입니다.<br>
</details>

<details markdown = "1">
<summary>버퍼 오버플로 공격이란 무엇인지 설명해주세요.</summary>
브루트포스(brute force)라는 의미 그대로 무차별 대입 공격을 말합니다.
브루트포스 공격 대상은 다양하지만 주로 시스템을 이용할 때 필요한 비밀번호나 암호키입니다.
이러한 공격에 대비하기 위해 비밀번호로 설정 가능한 조합의 수를 늘려 풀 수 있는 시간을 늘리는 수 밖에 없습니다.
모든 경우의 수를 대입하기 때문에 이론적으로 풀 수 없는 암호는 존재하지 않기때문입니다.<br>
</details>

<details markdown = "1">
<summary>크로스 사이트 스크립팅(XSS)이 무엇인가요?</summary>
XSS는 웹 애플리케이션의 취약성을 악용한 공격 수법으로, 사용자가 입력한 정보를 출력할 때 부정한 스크립트가 실행되도록 하는 공격기법입니다.<br>
ex) 사용자가 미끼 페이지 접속 -> 악의적 스크립트 있는지 모르고 웹페이지에 데이터 전송 -> 악성 스크립트가 포함된 response 반환 -> 결과적으로 악성 가짜 페이지로부터 공격 받게 됨.<br>
<br>
쿠키에 HTTPOnly 옵션을 활성화 하여 자바스크립트를 통해 쿠키값에 접근 못하게 하거나, 세션에 Sequre 기능활성화를 통해 HTTPS에서만 세션을 주고받게끔 할 수 있음.<br>
</details>

<details markdown = "1">
<summary>크로스 사이트 리퀘스트 포저리(CSRF)가 무엇인가요?</summary>
인터넷 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위 (modify, delete, register 등)를 특정한 웹사이트에 request하도록 만드는 공격을 말한다<br>
<br>
백엔드 단에서 Refferer 검증을 통해 승인된 도메인으로 요청시에만 처리하도록 한다.
Security Token 사용 -> 사용자의 세션에 임의의 난수 값을 저장하고, 사용자의 요청시 해당 값을 포함하여 전송시킨다. 백엔드 단에서는 요청을 받을 때 세션에 저장된 토큰값과 요청 파라미터로 전달받는 토큰 값이 일치하는 지 검증 과정을 거치는 방법<br>
</details>